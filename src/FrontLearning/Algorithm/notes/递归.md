<!--ts-->

<div align = "center"><font size = 4>递归</font></div>

* [一、什么是递归](#一什么是递归)
* [二、为什么用递归](#二为什么用递归)
* [三、什么样的问题可以用递归解决，递归有那些应用](#三什么样的问题可以用递归解决递归有那些应用)
* [四、如何写递归代码](#四如何写递归代码)
   * [1) 关键](#1-关键)
   * [2) 递推公式确定方法](#2-递推公式确定方法)
   * [3）思维误区及其解决方案](#3思维误区及其解决方案)
* [五、递归代码潜在缺点及其解决方案](#五递归代码潜在缺点及其解决方案)
* [六、递归代码改写为非递归代码（递归都可以改写成循环）](#六递归代码改写为非递归代码递归都可以改写成循环)
* [七、应用实例](#七应用实例)
* [八、拓展思考及其建议](#八拓展思考及其建议)
   * [1）如何进行递归代码的调试？](#1如何进行递归代码的调试)
   * [2）对于递归的使用态度](#2对于递归的使用态度)
* [九、复习递归知识的问题集合](#九复习递归知识的问题集合)



#### 一、什么是递归

---

1、定义：一种应用非常广泛的算法或者编程技巧。



#### 二、为什么用递归

---

很多数据结构和算法的编码实现都要用到递归



#### 三、什么样的问题可以用递归解决，递归有那些应用

---

应用递归的问题需要满足的三个条件：

- 一个问题的解可以分解为几个子问题的解
- 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
- 存在递归终止条件

递归可以用在比如 DFS 深度优先搜索、前中后序二叉树遍历等等。



#### 四、如何写递归代码

---

##### 1) 关键

写出递推公式，找到终止条件



##### 2) 递推公式确定方法

写递归代码的关键，就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。



##### 3）思维误区及其解决方案

- 误区：看到递归时总是想把递归平铺展开，脑子里就会循环，一层一层往下调，然后在一层一层返回，试图想搞清楚计算机的每一步都是怎么执行的。

- 解决方案：如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题，而且你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。

**总结：**只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。



#### 五、递归代码潜在缺点及其解决方案

---

- **堆栈溢出：**当递归求解的数据规模很大，调用层次很深一直压入栈，就会有堆栈溢出的风险。

  *解决：*可以限制最大深度方式解决这个问题，但是递归深度不好确定，或者到达一定深度如修改成非递归方法，如快排中变为子集，采用堆排序。如果知道递归深度很小。那么可以确定一个最大深度值。或者直接将递归代码改写为循环代码。或者使用尾递归优化(<font color=green>待定！</font>)，回归阶段不需要任何操作。

- **重复计算：** 就是比如 $f(n) = f(n-1) + f(n-2)$ 这样一个递归代码 f(3) 会计算 3 次等等。 

  _解决_： 用一个数据结构（比如散列表）来保存已经求解过的 $f(k)$。当递归调用到 $f(k)$ 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。

- **空间复杂度高：**会压栈和出栈，不断的占用空间。

  _解决：_ 尾递归优化、改为循环。

- **时间效率低：**通过层层函数调用，保存现场的时间会增加。

  *解决：* 如果压栈次数多，可能会造成时间上的增多，可以改为循环实现。


#### 六、递归代码改写为非递归代码（递归都可以改写成循环）

---

**优点:** 解决了递归代码含有的部分缺点{堆栈溢出、重复计算、空间复杂度高}。当然也可能是全部缺点，这与非递归代码的实现有关。

**关键: **根据递归的递推公式。直接改写为循环代码。



#### 七、应用实例

---

- 电影院求解自己在第几排：只要知道前一排的人是第几排。此时就知道我们所在第几排。这样递归下去： $f(n) = f(n-1) + 1\quad$，其中 $f(n)$ 表示当前自己所在排排数。$f(n-1)$ 表示前一排排数。$f(1) = 1$ 表示第一排的人知道自己在第一排。

- n 个台阶问题:  递推公式：$f(n)=f(n-1)+f(n-2)$ 其中 $f(1) = 1 \quad f(2) = 2$ 可以这样理解，最后一步，向前迈最后一个台阶时有两种情况，要么是在 n-1 台阶处，此时已经有 $f(n-1)$ 种情况了，要么是在 n-2 台阶处，此时已经有 $f(n-2)$ 种情况。或者可以如下理解(但是感觉不通顺)：

  > 可以根据第一步的走法，把所有走法分为两类，第一类是第一步走了1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。



#### 八、拓展思考及其建议

---

##### 1）如何进行递归代码的调试？

- 打印日志（可以选择 glog），查看递归值

- 结合条件断点进行调试

- 打印一个树型结构的日志，每进入一层，深度加 1 然后打印深度，比如深度可以用这种符号来表示 "--"，在符号后面接上值，换行，这样可以很清除的看到每次调用信息。以及总深度是多少。


##### 2）对于递归的使用态度

工作中尽量少使用递归，否则代码移植到堆栈小的处理器上，可能会出现堆栈溢出的 Bug。



#### 九、复习递归知识的问题集合

---

该讲内容总结为几个问题, 大家复习的时候可以先尝试回答这些问题检查自己的掌握程度:

- 递归需要满足的三个条件是什么?

- 写好递推代码的关键着手点是什么? 如何避免被一层层的逻辑绕进去?

- 写递推代码是如何避免堆栈溢出?

- 写递推代码如何避免重复计算?



<!--te-->