<!--ts-->

<div align = "center"><font size = 4>字符串匹配</font></div>

<font color="green">RK 算法是如何借助哈希算法来实现高效字符串匹配的呢？</font>




### 一、什么是字符串匹配

---

在一个主串中查找模式串，通常来说是一个串跟一个串进行匹配。比如 BF 和 RK 算法。也有多模式串的匹配算法，就是在一个串中同时查找多个串。这种是 Trie 树和 AC 自动机。



#### 1 BF 算法

​		一种暴力简单的字符串匹配算法，就在主串的起始位置开始，一直遍历，每次切换起始位置后，都会与模式串一一对比，假设主串长度为 n，模式串为 m，那么 BF 算法的时间复杂度为 $O(n*m)$。尽管复杂度高，但是在实际应用中用的比较多，一般在串的长度比较小时，效率比较高！



#### 2 RK 算法

> Rabin-Karp采用了把字符进行预处理，也就是对每个字符进行对应进制数并取模运算，类似于通过某种哈希函数计算其函数值，比较的是每个字符的函数值。预处理时间O(m)，理论匹配时间是O((n-m+1)m)。这里要乘以m是考虑到对hash值相同的进行一次校验;
>
> 由于hash冲突的存在，当hash值相同的时候，还是需要朴素算法来进行必要的比较,所以时间复杂性为O（m*n）。但是**现实中**hash冲突出现的可能性不是很大，所以相比较而言，复杂性还是比较小的，仅仅为O(m+n)

​		在 BF 算法的基础上，减少主串的子串与模式串一一对比消耗的时间，这里用哈希算法来改进，整体就是把子串映射为一个 hash 值，然后与模式串的哈希值进行比较，这样在比较环节就需要遍历一次，其复杂度为 $O(n)$，通常计算子串的哈希值都是要遍历每个子串的元素，如果这样做的话，整体复杂度本身并没有改变，仍然是 $O(n*m)$，我们的目的就是要改进哈希计算时不要把每个子串都遍历一遍。那么需要一个有技巧的 hash 算法，就是把子串的字符按照 a~z 26 个字母，变为 26 进制，这样的哈希算法执行后，每个子串都对应一个唯一的哈希值，可以发现找到的子串 i 与子串 i+1 之间会有部分重叠，只需要计算子串 i 的哈希值，然后通过递推方法就可以得到子串 i+1 的 hash 值。此时，在按照上面新的哈希算法计算哈希值时，就不需要遍历每个子串的元素了，降低了复杂度，此时计算每个子串的哈希值的复杂度就变为了 $O(n)$。所以整体上，先计算哈希值，然后在遍历每个哈希值一一比较，此时整体复杂度为 $O(n)$ ，下图是上面刚刚讲解的 26 进制的例子

<div align = "center"> 
  <img src = "pics/字符串匹配/RK1.jpg" width = "500px"/>
  <img src = "pics/字符串匹配/RK2.jpg" width = "500px"/> 
</div><br>
<div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

​		在上面的基础上还会出现一个问题，如果按照 26 进制来计算的话，如果字符串的长度超出 26，或者没有超出 26，但是得到 10 进制值时会超出整型的表示范围，那么我们不得不找到新的哈希算法（可能会增加哈希算法的冲突概率）来降低这种风险。比如举个简单例子，可以把子串的值全部加起来，这个算法当做哈希算法，其值作为哈希值，这样整体表达的整型范围小很多，那么增加了哈希冲突如何解决？我们可以对冲突的子串一一对比每个子元素，这可能也是唯一解决哈希冲突的方法，那么最坏情况下，假设每个子串都哈希冲突，那么我们每个子串都需要一一对比子元素，那么此时的时间复杂度其实就是 $O(n*m)$，但是这样的哈希冲突遇到的概率极低，所以整体来说 RK 算法的效率仍然要好于 BF 算法（当然针对一般的场景，如果主串太小，比如长度为 3，模式串为 2，那么直接用 BF 即可，效率还高）。

##### 优缺点

优点:

1. 它可以用来检测抄袭，因为它能够处理多模式匹配(多个不同长度的`m`)；
2. 虽然在理论上并不比暴力匹配法更优，但在实际应用中它的复杂度仅为O(n+m);
3. 如果能够选择一个好的哈希函数，它的效率将会很高，而且也易于实现。

缺点:

1. 有许多字符串匹配算法的复杂度小于O(n+m)；
2. 有时候它和暴力匹配法一样慢，并且它需要额外空间。



#### 3 BM（Boyer-Moore）算法

<font color="green">对于查找功能是重要功能的软件来说，比如一些文本编辑器，它们的查找功能都是用哪种算法来实现的呢？有没有比 BF 算法和 RK 算法更加高效的字符串匹配算法呢？</font>



##### 1 核心思想

在模式串和主串匹配时，如果主串中的某个字符 c 在模式串中是不存在的，那么模式串向后滑动的时候，只要该字符 c 与模式串有重合，肯定无法匹配，那么可以把模式串往后多滑动几位。这样的效率就会提升很快。



#### 4 KMP（Knuth-Morris-Pratt）算法

> **Knuth-Morris-Pratt 字符串查找算法**（常简称为“**KMP算法**”）可在一个主“文本字符串”`s`内查找一个“词”`m`的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。



### 链接

[字符串匹配--RK算法]([https://zachaxy.github.io/2017/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-RK%E7%AE%97%E6%B3%95/](https://zachaxy.github.io/2017/04/26/字符串匹配-RK算法/))

[串的模式匹配算法---RK](https://www.cnblogs.com/cobbliu/archive/2012/05/24/2517151.html)