<!--ts-->

<div align = "center"><font size = 4>图</font></div>

 * [一、什么是图](#一、什么是图)
 * [二、为什么要用图](#二、为什么要用图)
 * [三、如何使用图结构](#三、如何使用图结构)
    * [1 如何存储图](#1 如何存储图)
       * [1 邻接矩阵](#1-邻接矩阵)
       * [2 邻接表](#2-邻接表)
    * [2 图的应用例子](#2-图的应用例子)
 * [四、图的暴力搜索算法](#四、图的暴力搜索算法)
    * [1 广度优先搜索](#1-广度优先搜索)
    * [2 深度优先搜索](#2-深度优先搜索)
    * [3 适用范围](#3-适用范围)



### 一、什么是图

---

<font color="green">如何存储微博、微信等这些社交网络的好友关系？</font>



图是一种非线性表数据结构，顶点与顶点以及之间的连线构成一个图结构，根据边是否有方向，分为有向图和无向图。

度（degree）：跟顶点相连接的边的条数

<div align = "center"> 
  <img src = "pics/图/图.jpg" width = "500px"/> 
</div><br>
<div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

入度（In-degree）：指向该顶点的边的条数

出度（Out-degree）：从该顶点出发的边的条数

带权图（weighted graph）：每条边都有一个权重，比如可以表示 QQ 好友间的亲密度

<div align = "center"> 
  <img src = "pics/图/图_带权图.jpg" width = "500px"/> 
</div><br>
<div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>



### 二、为什么要用图

---

图中边和顶点可以表示应用场景的两个对象以及对象之间的联系，抽象的表达可以解决许多类似的问题，比如 QQ 微信 微博的的社交关系就用图来表示。



### 三、如何使用图结构

---

#### 1 如何存储图

##### 1 邻接矩阵

用一个二维数组来表示，数组元素 $a[i][j]$ 表示顶点 i 和顶点 j 之前的联系（根据图的分类：有向图、无向图、带权无向图）。如下图所示，无向图会浪费空间，但是简单直接，一些问题可以转换为矩阵的乘法！

<div align = "center"> 
  <img src = "pics/图/图_邻接矩阵.jpg" width = "500px"/> 
</div><br>
<div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

##### 2 邻接表

<div align = "center"> 
  <img src = "pics/图/图_邻接表.jpg" width = "500px"/> 
</div><br>
<div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

1 对应的链表表示，1 指向了 2，不过这样查找速度比较慢，可以将链表替换成平衡二叉搜索树（实际使用可以用红黑树），在查询的时候就有 logn 的速度找到 2 和 4 之间是否有联系。还可以用跳表或者动态的有序数组使用二分搜索，都可以有 logn 的速度进行快速查询！



#### 2 图的应用例子

比如微博的关系图，我们先根据微博期望支持的操作，来选定什么样的存储结构

- 判断用户 A 是否关注了用户 B

- 判断用户 A 是否是用户 B 的粉丝
- 用户 A 关注用户 B
- 用户 A 取消关注用户 B
- 根据名称的首字母排序，分页获取用户的粉丝列表
- 根据用户名称的首字母排序，分页获取用户的关注列表



根据这些操作，可以选定用邻接表方式（假定在内存中处理这些数据），根据 A 关注 B，A 是否是 B 的粉丝，此时就需要两个邻接表，一个是存储顶点向外指向的关系，另一种是存储指向该顶点的关系。后面又说根据首字母排序，那么说明邻接表每个位置不能用链表存储，应该使用比较快的查询、插入、删除的动态数据结构，比如可以用跳表，复杂度为 $O(logn)$，并且还是有序的存储。如果数据量太大，可以根据哈希算法分片到不同的机器上，然后根据顶点编号计算哈希值，之后到对应的机器上获取即可，如下图

<div align = "center"> 
  <img src = "pics/图/图_微博.jpg" width = "500px"/> 
</div><br>
<div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

如果不在内存中存放这些数据，我们也可以用数据库来存储这些数据，然后直接建立一个表，如下图所示，这里以逆邻接表为例，直接记录了 1 对应了 4，然后 2 对应了 1, 4。这样空间占用比较高，适合存储永久型数据。 

<div align = "center"> 
  <img src = "pics/图/图_微博2.jpg" width = "500px"/> 
</div><br>
<div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

### 四、图的暴力搜索算法

---

<font color="green">给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？</font>

下面两种方法既可以用在无向图，也可以用在有向图上。<font color="green">都是不带权重的图</font>



#### 1 广度优先搜索（**Breadth-First-Search，缩写为 BFS**）

> 是一种利用**队列**实现的搜索算法。简单来说，其搜索过程和“湖面丢进一块石头激起层层涟漪”类似。

一种层层推进的搜索策略，因为内部用邻接表来表示，所以每一层表示一个顶点对应的所有邻接表顶点。实现过程中需要记录访问过的顶点，以及搜索的路径，还有一个队列，保存与当前顶点相连的下一层顶点。

<div align = "center"> 
  <img src = "pics/图/图_广度优先搜索.jpg" width = "500px"/> 
</div><br>
<div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

**时间复杂度**：最坏情况，每个顶点都需要进入队列一次，每条边也需要访问一次，那么复杂度为 O(V+E)，对于一个连通图中（任意两个顶点都是联通的），边数一定大于顶点数 - 1，所以广度优先算法也可以协成 O(V)。



**空间复杂度**：空间消耗主要在 visited 数组、queue 队列、prev 数组上，所以空间复杂度为 O(V)。



#### 2 深度优先搜索（**Depth-First-Search，缩写为 DFS**）

> 是一种利用**递归**是实现的搜索算法。简单来说，其搜索过程和“不撞南墙不回头”类似。

利用一种回溯的思想，就是以深度优先的方式搜索整个解空间，在搜索过程中用剪枝函数，避免无效的搜索。这里深度优先就用了一个数组，来记录该顶点是不是被访问过。相当于剪枝函数，解空间应该是从起点能够终点的搜索可达路径。



**时间复杂度**：最坏情况下，每条边被访问了两次（包含回退），因此时间复杂度是 O(E)。

**空间复杂度**：与广度优先一致，要包含 visited、prev 数组和递归调用栈，递归调用深度最大不会超过顶点的个数，总空间复杂度就是 O(V)。



#### 3 适用范围

这两种搜索算法是图上最基本的最常用的，但是因为是穷举法，所以仅仅适用于状态空间不大的情况（图不大），广度优先需要借助队列来实现，深度优先需要借助栈来实现。两者的时间复杂度都是 O(E)，空间复杂度都是 O(V)。

#### 4 区别

**BFS 的重点在于队列，而 DFS 的重点在于递归。这是它们的本质区别。**

#### 5 举例

如下图，灰色代表墙壁，绿色代表起点，红色代表终点，规定每次只能走一步，且只能往下或右走。求一条绿色到红色的最短路径。

![](pics/图/alogrithm_graph_1.png)

对于上面的问题，BFS 和 DFS 都可以求出结果，它们的区别就是在复杂度上存在差异。我可以先告诉你，该题 BFS 是较佳算法。

**BFS示意图：**

![](pics/图/alogrithm_graph_2.gif)

如上图所示，从起点出发，对于每次出队列的点，都要遍历其四周的点。所以说 BFS 的搜索过程和 “湖面丢进一块石头激起层层涟漪” 很相似，此即 “广度优先搜索算法” 中“广度”的由来。

**DFS示意图：**

![](pics/图/alogrithm_graph_3.gif)

如上图所示，从起点出发，先把一个方向的点都遍历完才会改变方向...... 所以说，DFS 的搜索过程和 “不撞南墙不回头” 很相似，此即 “深度优先搜索算法” 中“深度”的由来。

#### 6 练习题

《[剑指Offer（三十八）：二叉树的深度](https://cuijiahua.com/blog/2018/01/basis_38.html)》