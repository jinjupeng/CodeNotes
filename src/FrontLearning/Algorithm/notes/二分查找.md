<!--ts-->

<div align = "center"><font size = 4>二分查找</font></div>

* [一、什么是二分查找](#一什么是二分查找)
* [二、二分查获找的思想](#二二分查获找的思想)
* [三、二分查找的复杂度 O(log(n))](#三二分查找的复杂度-ologn)
* [四、二分查找的实现方法（递归 VS 非递归）](#四二分查找的实现方法递归-vs-非递归)
   * [1）容易出错的地方](#1容易出错的地方)
   * [2）实现方法](#2实现方法)
* [五、二分查找的局限性](#五二分查找的局限性)
   * [1）依赖的是顺序表结构 — 数组](#1依赖的是顺序表结构--数组)
   * [2）针对有序的数组](#2针对有序的数组)
   * [3）针对插入和删除操作不频繁的场合](#3针对插入和删除操作不频繁的场合)
   * [4）针对数据量不能太小](#4针对数据量不能太小)
   * [5）数据量不能太大（最多占内存1/5）](#5数据量不能太大最多占内存15)
* [六、二分查找的变种](#六二分查找的变种)
* [七、二分查找的应用例子](#七二分查找的应用例子)
   * [1）如何在 100 万个整数中快速找某个整数](#1如何在-100-万个整数中快速找某个整数)
   * [2）求一个数的平方根，要求精确到指定位数](#2求一个数的平方根要求精确到指定位数)
   * [3）如何快速定位 IP 对应的省份地址](#3如何快速定位-ip-对应的省份地址)
* [八、思考](#八思考)
   * [1）为什么不能用链表方式来存储数据，进行二分查找？](#1为什么不能用链表方式来存储数据进行二分查找)
   * [2）二分查找 vs 散列表 vs 二叉树](#2二分查找-vs-散列表-vs-二叉树)



#### 一、什么是二分查找

---

是一种针对有序数据集合的查找算法。是一种最省内存的方式实现的快速查找的方法。



#### 二、二分查获找的思想

---

针对有序数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半。直到要查找的元素或者区间被缩小为 0 时，此时表示没有找到。



#### 三、二分查找的复杂度 O(log(n))

---

与二分查找复杂度相同的还有堆、二叉树操作。这种复杂度，有时候比常数阶复杂度的算法实际执行时间要快。因为常数阶 $O(1)$ 可能对应的是 $O(1000)$ 。

 

#### 四、二分查找的实现方法（递归 VS 非递归）

---

##### 1）容易出错的地方

- 终止条件
- 区间上下界更新方法
- 返回值选择



##### 2）实现方法

- 非递归方法
  - 循环退出条件：low <= high
  - mid 的取值：mid = low + (high - low)/2 ，不用 (high + low)/2 的原因，当 high 和 low 都很大时，此时两者之和可能会有溢出的风险。因此改为前一种方式。
  - low 和 high 的更新：low = mid + 1, high = mid - 1。这里的 1 实际上就是步长。针对不同的问题，这里的步长可能不同。
- 递归方法
  - 终止条件：low > high
  - 递推公式：f(区间) = f(区间/2)



#### 五、二分查找的局限性

---

##### 1）依赖的是顺序表结构 — 数组

如果利用链表来实现二分查找，那么在获取指定索引的元素值时，对于数组来说，复杂度为 $O(1)$，但是对于链表，复杂度变为 $O(n)$，也就是说，利用链表的方式来来实现二分，那么每次折半时，链表都会比数组的方法多了 $O(n)$ 的额外操作。复杂度会更高。



##### 2）针对有序的数组

二分查找只能用在排好序数据上，也就是在使用二分查找之前，一定要将数据进行排序。那么边际成本就是排序的复杂度。在排序中最快的复杂度也就是 $O(nlog(n))$ ，此时适合一次排序，多次查找的场合。



##### 3）针对插入和删除操作不频繁的场合

如果一组数据在排序完成后，除了查找操作外，还会进行一系列删除和插入操作。如果能够保证插入和删除操作之后，数据仍然是有序的，那么使用二分查获找总是可以的。或者插入和删除操作很少，那么在查找之前，需要排序数据这种边际成本可以容忍。但是，当一组数据总是会频繁动态的插入和删除，同时插入和删除的操作不能保证数据仍然是有序的。那么此时就不适合二分查找了。因为每次使用二分查找都需要排序数据。频繁插入和删除，会导致排序算法的执行次数大大增加。这样查找的边际成本太大。此时应该使用二叉树这种。适合动态数据，查找复杂度也同时是 $O(nlogn)$。



##### 4）针对数据量不能太小

当数据量小的时候，比如只有 10 个。我们可以直接一次性进行遍历即可找到某个值，那么时间复杂度是 $O(n)$ ，数据量小，会使复杂度接近常数阶。但是这个时候利用二分法，那么需要排序一次。然后在查找。那么实际执行时间，二分可能会大于直接顺序遍历。

<font color = green>特例</font>：当数据中会有比较耗时的比较操作时。比如一组数据的比较操作是字符串。那么此时我们应该减少比较次数。假设排序的操作不会比较字符串。那么此时还是优先选择二分查找的方法。保证比较的操作次数少于循环遍历方法。如果排序操作也会比较字符串，且查找不太频繁。那么还是优先使用循环遍历。



##### 5）数据量不能太大（最多占内存1/5）

因为二分算法是基于顺序表的。那么就需要申请很大的连续空间，一般来说，如果数据量太大，计算机内存空间会很难提供那么的大空间存储数据。



#### 六、二分查找的变种

---

- 查找第一个值等于给定值的元素
- 查找最后一个值等于给定值的元素
- 查找第一个大于等于给定值的元素
- 查找最后一个小于等于给定值的元素



#### 七、二分查找的应用例子

---

##### 1）如何在 100 万个整数中快速找某个整数

100 万个整数大小占据 80M 空间，符合内存限制，可以使用二分查找方法。虽然二叉树和散列表方式也是可找到。但是这两种方法，需要耗费额外的空间。因此二分方法是最省内存空间的方法。且复杂度也是 $O(log(n))$



##### 2）求一个数的平方根，要求精确到指定位数

- 利用二分思路，一位一位进行确定。
- newton 方法，用循环迭代的方式找到精确解。是平方阶收敛



##### 3）如何快速定位 IP 对应的省份地址

将 IP 地址表的初始地址（终止地址不作处理）转化为 int 类型数据，然后排序（小--->大）。之后查找最后一个小于等于给定值的元素。判断给定值是否在找到的初始地址对应的地址区间。如果给定值在该区间，那么读取对应的省份即可。否则失败。



#### 八、思考

---

##### 1）为什么不能用链表方式来存储数据，进行二分查找？

对于链表方法来说，每次除了比较操作外，还需要进行 $O(n)$ 的获取指定索引值的操作。那么依次是

$n/2 \quad n/2^2 \quad n/2^3 ...\quad n/2^k $ 此时 k = log(n)，这个是等比数列，求和后可以发现，此时链表实现的二分查找复杂度是 $O(n)$ ，我们知道即使循环遍历一遍数据也是 $O(n)$，如果用链表的话，还需要排序，链表遍历的赋值操作等等，造成实际执行时间和空间复杂度会远高于基于数组的二分法和循环遍历方法。



##### 2）二分查找 vs 散列表 vs 二叉树

一般精确查找的地方，会用散列表和二叉树代替二分查找。因为内存不够的情况比较少见。而对于二叉树来说，更适合「近似」查找问题。比如上面说的二分查找的变种。

<!--te-->