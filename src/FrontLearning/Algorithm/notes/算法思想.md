<div align = "center"><font size = 4>算法思想</font></div>

### 一、贪心算法

---

如果该问题可以证明当前决策即不受之前决策影响和对后续决策的影响，那么贪心算法就可以解决最优解问题。



建模方法：在每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。



### 二、分治算法

---

解决的问题满足如下条件：

- 原问题与分解成的小问题具有相同的模式
- 原问题分解成的子问题可以独立求解，子问题之间没有相关性（这点与动态规划是不同的）
- 具有分解终止条件，当问题足够小时，可以直接求解
- 可以将子问题合并成原问题，并且合并的复杂度不能太高（重点！），否则无法起到减小算法总体复杂度的效果



一般分治算法将问题分解为多个子问题的方式，可以用多线程或者多机来处理。单核多线程能够执行的原因是，算法都包含内存访问和 CPU 计算两部分，因此在访问内存时，CPU 就会空闲，此时可以通过调度其他线程来充分利用 CPU。



例子：

- 求出一组数据的有序对个数或者逆序对个数
- 二维平面上有 n 个点，如何快速计算出两个距离最近的点对
- 有两个 n*n 的矩阵 A B，如何快速求解两个矩阵的乘积 C = A * B



### 三、回溯算法

---

回溯算法本质上就是枚举，优点是类似于摸着石头过河查找策略，当问题的解空间维度足够大，那么我们可以一维一维的枚举所有情况，但是回溯算法中会有剪枝操作，把一些不符合条件的方案提前否定掉。当一些问题缺乏某种规律时，我们就可以一步一步的进行寻找解空间。



经典问题：8 皇后、0-1 背包、正则表达式



### 四、动态规划

---

回溯 + 备忘录 <=效率=> 动态规划

动态规划一般适用于解决「一个模型三个特征」

- 多阶段决策最优解模型
- 最优子结构：问题的最优解包含子问题的最优解，通过求解子问题的最优解推导出问题的最优解。
- 无后效性：在推导后面阶段的状态时，只关心前面阶段的状态值，某阶段一旦确定，就不受后面阶段的影响
- 重复子问题：不同的决策序列，也就是回溯算法画出的递归树中有重复的子状态。



解题思路总结：

- 状态转移表法：由回溯算法+递归树推断出状态节点，根据动态规划适用于解决的问题特性，判断当前问题是否可以利用动态规划来解决，如果可以用动态会话解决，此时需要根据递归树和回溯算法确定好状态，然后建立一个状态转移表（一般是二维的，高维的无法适用），在根据最优子结构也就是状态转移方程来决定如何更新状态转移表，其实最为本质的还是要知道状态转移方程是怎么来的，此时才能知道状态状态转移表如何更新！
- 状态转移方程法：就是根据状态转移方程通过递归来实现的方法，重点也是求解出状态转移方程。

这两种思路其实重点仍然是写出状态转移方程，当然可以不写出来，比如背包问题，可以直接想到状态是如何转移的，但是对于网格路径问题，我们必须要分析出状态转移方程，才知道状态转移表如何更新。所以动态规划的重点是能不能找到最优子结构。



### 五、四种算法思想

---

贪心、回溯、动态规划分为一类可以抽象成多阶段最优解模型，分治分为另一类，无法抽象成多阶段决策模型。

