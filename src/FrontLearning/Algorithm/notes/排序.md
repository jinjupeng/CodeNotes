<!--ts-->

<div align = "center"><font size = 4>排序</font></div>

* [一、排序算法总览（表）](#一排序算法总览表)
* [二、如何分析一个排序算法](#二如何分析一个排序算法)
   * [1）排序算法的执行效率](#1排序算法的执行效率)
   * [2）排序算法的内存消耗](#2排序算法的内存消耗)
   * [3）排序算法的稳定性](#3排序算法的稳定性)
* [三、第一类「排序算法」O(n^2)](#三第一类排序算法on2)
   * [1）冒泡排序（比较   移动）](#1冒泡排序比较--移动)
   * [2）插入排序（比较   移动）](#2插入排序比较--移动)
   * [3）选择排序（比较   移动）](#3选择排序比较--移动)
   * [4）总结](#4总结)
* [四、第二类「排序算法」O(nlog(n))](#四第二类排序算法onlogn)
   * [1）归并排序（Merge Sort）](#1归并排序merge-sort)
   * [2）快速排序（Quick Sort）](#2快速排序quick-sort)
   * [4）总结](#4总结-1)

- [五、第三类「排序算法--线性排序」O(n)](#五第三类排序算法--线性排序on)
  - [1）桶排序（Bucket sort）](#1桶排序bucket-sort)
  - [2）计数排序（Counting sort）](#2计数排序counting-sort)
  - [3）基数排序（Radix sort）](#3基数排序radix-sort)
- [六、排序算法优化策略](#六排序算法优化策略)
  - [1）一般原则](#1一般原则)
  - [2）应用分析 — C 中的 qsort() 函数 ](#2应用分析--C-中的-qsort-函数)



#### 一、排序算法总览（表）

----

**Note**：下面的时间复杂度指的是平均情况。

| 排序算法                   | 时间复杂度   | 是否基于比较 | 内存消耗                    | 稳定性                     |
| -------------------------- | ------------ | ------------ | --------------------------- | -------------------------- |
| 冒泡、插入、选择           | $O(n^2)$     | 是           | 原地排序                    | 冒泡和插入是稳定的         |
| 快排、归并                 | $O(nlog(n))$ | 是           | 归并：$O(n)$   快排：$O(1)$ | 归并：稳  快排：非稳       |
| 桶排序、计数排序、基数排序 | $O(n)$       | 否           | 空间复杂度为 $O(n)$         | 计数：稳 基数：稳 桶：非稳 |



#### 二、如何分析一个排序算法

---

需要从以下三个方面进行分析：

##### 1）排序算法的执行效率

- 最好情况、最坏情况、平均情况时间复杂度

  > 备注：需要知道分别对应什么样的原始数据，数据的有序程度会影响排序算法性能。

- 时间复杂度的系数、常数、低阶

  > 对于同一阶时间复杂度的算法做性能对比时，要把系数、常数、低阶也考虑进来

- 比较次数和交换次数(或移动)次数

  > 对于同一类算法，需要比较不同实现的比较和交换次数。比如 $O(n^2)$ 的排序算法之间。



##### 2）排序算法的内存消耗

原地排序：空间复杂度是 $O(1)$ 的排序算法。



##### 3）排序算法的稳定性

待排序列中存在值相等的元素，经过排序后，相等元素之间原有的先后顺序不变。比如 2 9 3 4 3 ---> 2 3 3 4 9 两个 3 的前后顺序不变，即为**稳定排序排序算法**。否则为**不稳定排序算法**。

**Note**：为什么要求稳定性？

因为稳定排序算法可以保证大小相等的元素不必互换位置。减少了计算量。在开发过程中，排序的东西大部分都是与对象有关。然后根据 _Key 进行比较。在一定程度上减少了拷贝与赋值。



#### 三、第一类「排序算法」O(n^2)

---

##### 1）冒泡排序（比较 + 移动）

*基本思路*：操作相邻的两个元素，每次冒泡都会对相邻的两个元素进行比较，看是否满足大小关系。如果不满足就让他俩互换。一次冒泡至少让一个元素移动到应该在的位置。重复 n 次，即完成 n 个数据的排序工作。

- 原地排序算法

- 稳定的排序算法

- 时间复杂度

  - 最好情况：数据已经是有序的，只需一次冒泡，$O(n)$

  - 最坏情况：数据是倒序的，需要进行 n 次冒泡，$O(n^2)$

  - 平均情况：$O(n^2)$ 基于如下有序度概念推倒出来的。

    - 有序度概念：

      **有序度**：数组中具有有序关系的元素对的个数。

      ```c++
      有序元素对：a[i] <= a[j], 如果 i < j。
      ```

      **满有序度**：任意两个元素都是有序的，总共有 $C_n^2 = n*(n-1)/2$ 种情况。

      **逆序度**：与有序度相反

      ```c++
      逆序元素对：a[i] > a[j], 如果 i < j。
      ```

      「**逆序度 = 满有序度 - 有序度**」

      包含两个原子操作，比较和交换（也就是双层循环内部执行的语句）。每交换一次，有序度就增加 1。实际上交换的总次数就是原始数据的**逆序度 = n*(n-1)/2 - 初始有序度** 。

    - 具体分析：

      最坏情况需要交换 $n*(n-1)/2$ 次，最好情况为 0 次。平均需要交换 $n*(n-1)/4$ 次。又因为比较操作又比交换操作多，而复杂度上限为 $O(n^2)$ ，所以平均复杂度也是 $O(n^2)$。



##### 2）插入排序（比较 + 移动）

*基本思路*： 将数据分为已排序区间和未排序区间。初始已排序区间为 1 个元素，就是数组的第一个元素。然后依次取出未排序区间的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。直到未排序区间中的元素为空。

- 原地排序算法
- 稳定排序算法
- 时间复杂度
  - 最好情况：数据是有序的，只需要 $O(n)$  
  - 最坏情况：数据完全无序，需要 $O(n^2)$
  - 平均情况：$O(n^2)$ ，在数组中插入数据平均复杂度为 $O(n)$，然后有外层循环 n 次。



##### 3）选择排序（比较 + 移动）

*基本思路*：将数据同样分为已排序区间和未排序区间。然后在未排序区间中找到最小元素，将其放到已排序区间的末尾。初始序列为未排序区间。可以实现成稳定的选择排序，只是本质仍然是冒泡排序。

- 原地排序算法
- 不稳定排序算法
- 时间复杂度
  - 最好情况：数据有序，只需要 $O(n^2)$ 
  - 最坏情况：完全无序，只需要 $O(n^2)$
  - 平均情况：$O(n^2)$ 



##### 4）总结

相比于冒泡排序，插入排序更受欢迎。是因为在同样逆序度下，冒泡排序需要 3 行的数据交换操作，而插入排序仅仅需要 1 行的交换操作。在大数据下。冒泡排序要比插入排序花费更多的时间。经过自己尝试 10000 个数据，冒泡排序时间要大于插入排序 5 倍。三种排序算法的详细对比。

| 排序算法 | 是原地排序? | 是否稳定？ | 最好     | 最坏     | 平均     |
| -------- | ----------- | ---------- | -------- | -------- | -------- |
| 冒泡     | 是          | 是         | $O(n)$   | $O(n^2)$ | $O(n^2)$ |
| 插入     | 是          | 是         | $O(n)$   | $O(n^2)$ | $O(n^2)$ |
| 选择     | 是          | 否         | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ |

**Note**: 冒泡和选择排序实际中用的并不多，插入排序会在排序优化的时候会用到。对于小规模数据的排序，可以使用上面三种，大规模数据需要复杂度更低的算法比如 $O(nlog(n))$。



#### 四、第二类「排序算法」O(nlog(n))

---

下面的归并排序和快速排序都用到了**分治思想**。可以借助这种思路解决非排序的问题。比如在 $O(n)$ 的时间复杂度内查找一个无序数组中的第 K 大元素。



分治是一种解决问题的处理思想，递归是一种编程技巧。下面两种排序算法都是用了递归实现。归并排序重点是理解递推公式和 merge() 合并函数。快排的重点是递推公式和 partition() 分区函数。



##### 1）归并排序（Merge Sort）

*基本思路*：如果是一个数组，先把数组分成两部分，对前半部分和后半部分分别排序。再将排好序的两部分合并在一起。这样整个数组就是有序的了。一般实现方式都是用递归。也就是先「分解」在「合并」。

- 递推公式

  ```c++
  // 把下标为 p 到 r 的数组进行排序。
  merge_sort(array) = merge(merge_sort(p...q), merge_sort(q+1...r));
  
  // 终止条件: 就是无法在继续划分下去
  p >= r 不用在继续分解
  ```

- 非原地排序算法：空间复杂度为 $O(n)$ ，详细解释会与时间复杂度一起。

- 稳定排序？：取决于 Merge 函数，合并两个有序数组的实现方式。专栏中的实现和自己的实现方式都是稳定的排序算法。

- 时间复杂度：最好、最坏、平均情况都是 $nlog(n)$

  > 如何分析一个递归代码的复杂度？
  >
  > $T(a) = T(b) + T(c) + K$ 即 多个子问题的时间复杂度 + 合并时的时间复杂度
  >
  > 首先根据递推公式，可以设置当前时刻的时间复杂度为 $T(n)$
  > $$
  > \begin{align}
  > T(n) &= 2T(n/2) + n \\
  > 		 &= 2(2T(n/4) + n/2) + n = 2^2T(\dfrac{n}{2^2}) + 2n\\
  > 		 &= \quad ... \\
  > 		 &= 2^k T(\dfrac{n}{2^k}) + kn\\
  > \text{其中}\quad T(1)=C		 
  > \end{align} \\
  > $$
  > 从上面可以看出当 $2^k = n$ 可以得出 $k = log_2(n)$。 

  **结论**：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。

- 空间复杂度

  > 与时间复杂度的分析方法不同。因为 CPU 在同一时刻只能执行一个代码块。所以不能像时间复杂度那样直接累加。在执行归并函数时实际上只有在 Merge 函数，即把两个有序数组合并成一个有序数组时，会开辟一块大的内存空间。这个时候的空间复杂度最大就是 $O(n)$。



##### 2）快速排序（Quick Sort）

*基本思路*：与递归思路相似。也是将数组分成两部分。但是有一点不同。就是在划分的时候，快速排序是先随机选择一个分界点 pivot 。然后根据 pivot 的值，将数组分成小于该值和大于该值两部分。然后在小于其值的部分和大于其值的部分再次按照相同的思路继续划分。最后就会把整个数组排好序。

**Note** : 一般在自己实现的过程中都是选择最后一个值作为 pivot。这么做主要是为了让空间复杂度为 $O(1)$。也就是达到原地排序的目的。

- 递推公式

  ```c++
  // 递推公式：
  quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)
  
  // 终止条件：就是无法在继续分下去
  p >= r
  ```

  注意在实现过程中需要有一个分区函数。就是获得一个数组的分区点 pivot。有两种实现方式：一是直接建立两个临时数组分别存储左分区和右分区。这样做空间复杂度会跟归并排序一样。二是原地排序，直接选择数组最后一个元素作为 pivot 。用 pivot 将数组分割成两部分，相当于选择排序中的未处理区间和已处理区间。每次在未处理区间中拿出一个元素与 pivot 值进行对比，如果小于这个值，就要把其放已处理区间的结尾处。这个放到已处理区间的操作其实就是数据插入数组中的操作。如果按照通常的数组插入数据的方式看，需要移动数据。但是我们可以用一个「交换」的思维。插入的数据位置和被插入的数据位置对应的数据进行交换。这个就是一个 $O(1)​$ 的数组插入操作。这个是一个比较有技巧的操作，可以再次参照代码或者专栏上面图片显示的处理过程。

- 原地排序

- 不稳定排序

- 时间复杂度

  - 最好：$O(nlog(n))$  ，每次分区恰好将数组分割成两半。
  - 最坏：$O(n^2)$ ，就是数据是有序的情况下或者分区及其不均等。
  - 平均：$O(log(n))$ 需要在递归树哪里具体分析。

- 应用

  - 在 $O(n)$ 的时间复杂度内查找一个无序数组中的第 K 大元素

    > 借鉴分治思想和快速排序思路。把一个数组分割成两个部分，左边是大于 pivot 。右边是小于 pivot。如果分割点索引恰好是 K-1 。那么该分割点对应的值就是第 K 大元素。 如果 pivot 索引 > K-1 ，说明在 pivot 左边中存在第 K 大元素。如果 pivot 对应的索引 < K-1，说明在 pivot 右边中存在第 K 大元素。此时需要注意的是 K = K -1 - pivot 需要进行更新。

    复杂度分析：

    > 每次平均查找为 n/2，接下来依次为 n/4、n/8、n/16...。直到为 1。这个是一个等比数列。公比为 2。项数为 $log_2(n)$ 次。所以根据等比数列求和公式可以得到如下：
    >
    > $(1-2^{log_2(n)})/(1-2) = n/2$ 所以复杂度为 $O(n)$。

  - 现在你有 10 个接口访问日志文件，每个日志文件大小约 300 MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？

    > 答：目前来说最好的方式就是利用有序数组的合并，也就是归并排序的「并」。如果按照这个思路直接做的话，那就是每个文件读取一个数据，然后比较最小的数据。放到最终的文件中。然后在对应文件中再次取出一个数据。这样的时间复杂度其实就是 $O(n)$ 。为了充分利用内存或者提高文件流的读写速度。可以预先在每个文件读取 40M 数据，以及建立 400M 空间存储「并」的数据。此时用了 800M 的空间。然后 10 个 40M 的数据一起根据上面的思路做「并」，然后哪个数组中 40 M 没了，那么再次在对应文件中读取数据。当 400 M数据满了之后，写入文件。之后下次再用。



##### 4）总结

归并排序虽然时间复杂度稳定在 $O(log(n))$，但是空间复杂度较高为 $O(n)$，在大数据的时候用的比较少。快速排序更常用，快速排序只有在最坏的情况下才是 $O(n^2)$ ，但是这种情况比较少出现。又是一个原地排序。所以大数据时更常用。但是有一个缺点就是递归的层次会太高。所以使用的过程中需要克服递归层次高的问题。

| 排序算法 | 是原地排序? | 是否稳定？ | 最好         | 最坏         | 平均         |
| -------- | ----------- | ---------- | ------------ | ------------ | ------------ |
| 归并排序 | 否          | 是         | $O(nlog(n))$ | $O(nlog(n))$ | $O(nlog(n)$  |
| 快速排序 | 是          | 否         | $O(nlog(n))$ | $O(n^2)$     | $O(nlog(n))$ |



#### 五、第三类「排序算法--线性排序」O(n)

---

下面三个排序算法的时间复杂度是线性的，称为线性排序，且非基于比较的排序算法，不涉及元素之间的比较操作。重点掌握这些排序算法的适用场景。



##### 1）桶排序（Bucket sort）

*基本思路*：将所有的数据（数据范围比较大）**均匀**分装到有顺序的 m 个桶内（比如一个桶就装 0-9 的范围，另一个桶装 10-19 的序号），每个桶有 $k = n/m$ 个数据，桶内进行 $O(klog(k))$ 的排序算法。可以选择快速排序（不稳定）、或者归并排序（稳定）。此时总共的时间复杂度为 $O(m * k*log(k)) = O(nlog(n/m))$ 当 m 接近 n 时，此时近似为 $O(n)$。

- 是否是原地排序？（空间复杂度 $O(n)$）

  非原地排序，首先在第一个分桶阶段就需要申请空间，所以此时需要额外的空间，就是总数据量 n。其次桶内排序方法也会有涉及到空间变化。如果桶内排序是快排，桶内空间复杂度为 $O(1)$ ，如果是归并排序，桶内空间复杂度为 $O(k)$。但是在同一时刻只进行一个操作。所以空间复杂度最大是 $O(n)$。

- 是否是稳定的排序？

  与上同理，如果桶内是快排，那么是非稳定的排序，如果是归并排序，那么是稳定的排序。

- 时间复杂度分析

  - 最好情况：$O(n)$ 数据能够根据 m 个桶，均匀的划分其中。此时如基本思路那样是 $O(n)$ 的时间复杂度。
  - 最坏情况：$O(nlog(n)$ ，此时数据不会进行均匀的划分，有些桶内数据量占一半以上还多，有些很少。那么桶内数据多的进行快排或者归并排序的时候，就是 $nlog(n)$ 。那么整体上仍然是 $nlog(n)$。
  - 平均情况：$O(n)$。

- 应用场景

  数据的范围不大，远小于数据值。这样桶的数量也能接受。并且数据在经过划分后，每个桶内的数据很均匀。一般适用于外部排序(即数据存储在外部磁盘中，数据量比较大，内存有限)。



##### 2）计数排序（Counting sort）

是桶排序的一种特殊情况（数据范围不大，数据个数远远大于数据范围，比如学生的成绩排序，成绩在 0-100 ，但是人数却大于 100）。

*基本思路*：就是把 n 个数据，找到最大值和最小值，确定范围，然后根据范围来确定需要多少个桶，且按照值的大小顺序依次编号(从 0 开始)。这样的话，每个桶内的数据都是一样的值。然后用数组记录每个桶有多少个同样的值，桶的编号与数组索引号一致。然后根据该计数数组，从后向前遍历原数据，就可以稳定恢复所有数据的顺序排列。

- 是否原地排序？空间复杂度 $O(n)$

  非原地排序，首先在计数阶段，就是一个「范围」数量的空间。顺序排序时，需要申请临时的且与原数据同样大小的空间。综上就是一个非原地排序

- 是否是稳定的排序？

  是一个稳定的排序，因为这里与上面的桶排序不同，桶内的数据其实是有序的，不需要排序，且排序过程中因为是从后向前遍历数据。所以是一个稳定的排序。

- 时间复杂度分析 $O(n)$

  最好、最坏、平均：$O(n)$。因为计数排序已经知道桶内不需要在进行排序了。只需要计数每个桶内的数据，以及根据计数结果恢复原始数据顺序。因此复杂度不会变化。这也是与桶排序的最大不同。对于桶排序来说，每个桶装内数据量是否均匀，在桶内进行排序时会影响整体的复杂度。

- 应用范围

  用在数据范围不大。最好数据范围 k 比要排序的数据量 n 小。或者大不点。并且计数排序只能给负整数直接排序。如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。比如可以将一个包含负数的序列通过移位，变为非负数。如果是小数，那么可以将数据乘以 10 或者其他变为整数。

  *Note* 自己在实现的过程中可以处理整数数据。



##### 3）基数排序（Radix sort）

*基本思路*：假设数据按照自己带有的属性可以划分成高低位，且带有级别属性，高级别位「大小」能够决定整个数据的「大小」。那么可以先对低级别位先排序，然后依次递增排序高级别位。比如电话号码有 11 位，如果比较大小，按位来说，最后个位级别最低，只要高位数字越大，越说明该电话号码越大。那么可以先对个位排序整个数据（桶排序/计数排序），然后在按十位进行排序，最后按照最高位进行排序，那么此时电话号码就是有序的。在比如订单{价格、时间}问题，要求整体上是按照价格排序，价格相同按照时间排序。这说明价格这个属性级别高于时间属性，所以先对低级别属性，即时间排序。然后在根据价格排序。此时就是一个稳定的排序算法。

**Note**：在选择具体的排序算法时必须是**稳定的排序**，否则失效。

- 是否是原地排序？

  这个与所用的具体排序算法有关。如果自己用了快排，那么就是原地的，如果用了归并排序，那么就是非原地的

- 是否是稳定的排序？

  因为在排序每个「位」时候要求是稳定排序，所以这个肯定是稳定的排序。

- 时间复杂度分析

  因为对每位都进行 $O(n)$ 排序，也就是限定了桶排序或者基数排序。

  - 最好情况：$O(n)$ 对于桶排序，每个桶内排序是均匀的。或者用了基数排序。
  - 最坏情况：$O(nlog(n))$ 对于桶排序，每个桶内数据严重不均匀。
  - 平均情况：$O(n)$ 

**要求：**数据可以分割出独立的「位」来比较，且「位」之间有递进的关系，a 数据高位比 b 数据高位大，那么剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 $O(n)$ 了。

- 应用

  > 1、假设需要对 D, a, F, B, c, A, z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母前，但小写字母和大写字母不要求有序。比如经过排序之后为 a, c, z, D, F, B, A 这个如何来实现？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放在前面，大写字母放在最后，数字放在中间，不用排序算法，又该如何解决？
  >
  > 答：对于第一个问题，可以用线性排序的思路。就用桶排序，那么就是分割两个桶，一个是小写字母，一个是大写字母。但不是最优的。最优方法是用两个快慢指针，一个从前向后移动遇到大写就停下，一个从后向前移动遇到小写就停下。交换两个指针指向的元素。知道两个指针指向相同的元素为止。
  >
  > 对于第二个问题，也是用桶排序思路。分为 3 个桶。最优实现是，用两个指针第一次先是按照是小写字母和非小写字母排序，然后第二部分非小写字母，在用 2 个指针，按照大写字母和数字进行排序。
  >
  > 综上，最优实现的方法都是原地排序，且复杂度为 $O(n)$。另一种方式虽然也是 $O(n)$ 的时间复杂度，但却不是原地排序，空间复杂度为 $O(n)$。

| 排序算法 | 是原地排序? | 是否稳定？           | 最好   | 最坏         | 平均                     |
| -------- | ----------- | -------------------- | ------ | ------------ | ------------------------ |
| 桶排序   | 否          | 根据桶内排序算法决定 | $O(n)$ | $O(nlog(n))$ | $O(n)$                   |
| 计数排序 | 否          | 是                   | $O(n)$ | $O(n)$       | $O(n+k)$ ，k是数据范围   |
| 基数排序 | 否          | 是                   | $O(n)$ | $O(nlog(n))$ | $O(dn)$ d 是数据「位」数 |



#### 六、排序算法优化策略

---

##### 1）一般原则

- 对于数据量小的可以直接用插入排序。对于数据量大的(百 MB)可以用快排。数据量适中，比如 几百 kb 到 10 MB 以下，可以用归并排序，归并排序空间翻番。

- 最常用的其实是快速排序。因为快排最坏情况对应的 $O(n^2)$ ，也就是 pivot 选取的不合适时，因此选择适当的 pivot 是改进快排的主要优化方法。下面是优化快速排序的方法。

  - 三数取中法：从区间的首、尾、中间，分别选出一个数，然后选择中间值作为分区点。或者更进一步「五数取中」或者「十数取中」。
  - 随机法：随机选择下标索引作为分区点。从概率角度讲。$O(n^2)$ 出现的概率很小。

  **注意**：要警惕快排的递归堆栈溢出问题{设置递归深度、手动模拟递归}

##### 2）应用分析 — C 中的 qsort() 函数 

- 数据量小(1KB~2KB)，qsort() 优先使用归并排序
- 数据量大(100MB)，qsort() 会改为快速排序。且使用「三数取中法」
- 自己实现了一个堆上的栈，手动模拟递归类解决的。（后面的知识点）
- 快排中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序。此时 $O(n^2)$ 时间复杂度算法，实际执行时间可能会比 $O(nlog(n))$ 算法执行时间长。
- 且内部在插入排序的算法中也利用了哨兵来简化代码。提高了执行效率。

<!--te-->