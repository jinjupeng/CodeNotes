<!--ts-->

<div align="center"><font size = 4>哈希算法</font></div>

- [一、什么是哈希算法](#一、什么是哈希算法)
- [二、设计哈希算法要求](#二、设计哈希算法要求)
- [三、哈希算法应用](#三、哈希算法应用)



#### 一、什么是哈希算法

---

将任意长度的二进制值串映射为固定长度的二进制值串，映射规则称为**哈希算法**。而映射后的二进制值串称为**哈希值**。



#### 二、设计哈希算法要求

---

- 从哈希值不能反向推导出原始数据
- 对输入数据非常敏感，原始数据变化一个 Bit，最后得到的哈希值也是大不相同
- 散列冲突的概率非常小，不同的原始数据，哈希值相同的概率非常小
- 哈希算法的执行效率要尽量高，针对较长的文本，也能快速计算哈希值



#### 三、哈希算法应用

---

- **安全加密** — 从哈希值不能反向推导出原始数据。散列冲突的概率非常小，MD5 一般为 1/(2^128)

- **唯一标识** — 以图片库搜索某张图片为例，从图片上获取一些特定位置像素，通过哈希算法形成唯一标识码，作为图片唯一标识（信息摘要）。然后以散列表形式存储标识码及图像本身到数据库。之后根据唯一标识可以在散列表中快速找到相同 mapped value 的图片，对于映射到相同索引的图片可以进行所有像素的比对。

- **数据校验** — 下载 2GB 电影，分成 100 块下载，每块根据其内容计算哈希值，下载成功后再次进行哈希值比对，如果比对正确，则说明下载过程中网络传输没有出现错误。

- **散列函数** — 本质与哈希算法一致，散列函数是哈希算法的特例，散列函数侧重于执行效率，以及散列值的均匀性。

- **负载均衡** — 要求在同一个客户端上，一次会话中的所有请求都路由到同一个服务器上，可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将哈希值与服务器列表的大小进行取模计算，最终得到的值就是客户端对应的服务器编号。这实际上就是散列表的实现原理！

- **数据分片** — 以大数据「关键词日志」为例，利用多个机器并行处理大数据，将每个数据计算哈希值，将其与机器个数 n 取模。此时每个数据都会分配到对应的机器上。之后同一个关键词会被相同的机器处理，然后每台机器统计每个关键词的数量即可（里面有不重复的关键词对应同一台机器，也就是所谓的冲突）。在**唯一标识**哪里，如果图片集是 1 亿张，那么无法在一台机器上建立散列表，此时需要将图片分给多个机器，这里也按照数据分片思想，每张图片的标识符与计算机台数 n 取模（这里的 n 可以大概估算出来），之后分配到对应的机器，分别建立散列表。

  **NOTE**：海量数据处理问题，都可以采用多机分布式处理。借助分片思路，可以突破单机内存、CPU 等资源的限制。上面哈希值 n 取模的方法，其实有一个弊端，如果数据量动态变大，那么增加一台机器时，此时需要重新计算所有数据分配到哪个机器上。这样会造成雪崩效应。下面**分布式存储**方案，很好的解决了这个问题。数据分片方法仅仅适用于机器资源固定的场合。

- **分布式存储** — 数据哈希值的范围划分成 m 个区间，每个机器负责 m/k 个区间，其中 k 是当前机器个数。此时在增加一台机器，那么只需要拷贝某几个区间的值到新的机器上。这种方法称为**一致性哈希**。解决了分布式系统的扩容、缩容导致数据大量搬移的难题。



**问题**：你会直接存储用户密码这么重要的数据吗？仅仅 MD5 加密一下存储就够了吗？

> 实际上这样做是不够的，因为 MD5 虽然加密后无法反向推导。但是只要获得了加密后的文件。通过彩虹表（简单密码的 MD5 值）一一 比对，仍然能够破解一些简单的密码。这就是所谓的字典攻击。
>
> 可以通过引入一个 salt。也就是类似与注册时，会收到一个验证码，最终密码 = 你的密码 + 验证码，通过将「最终密码」进行 MD5 加密，此时得到的密文破解的难度会大大增加。

<!--te-->